import { verifyPassword } from "./util";
import { Mongo } from "meteor/mongo";
import { GestureType, FunctionType, defaultMapping } from "/imports/gesture/gesture";

// Define the structure of a User document
export interface User {
  // Unique user ID (auto-generated by MongoDB)
  _id: string;

  // User's email address (used as login identifier)
  email: string;

  // User's hashed password
  password: string;

  // Timestamp for when the user account was created
  createdAt: Date;

  // User’s custom gesture-to-function mapping preferences
  settings: Record<GestureType, FunctionType>;

  // Optional field to track the user's most recently used presentation
  _recent_presentation_id?: string;
}

// Create a MongoDB collection for storing user documents
export const UserCollection = new Mongo.Collection<User>("users");

// Define database permissions (⚠️ unrestricted; should be secured in production)
UserCollection.allow({
  // Allow anyone to insert new user documents
  insert: () => true,

  // Allow anyone to update user documents
  update: () => true,

  // Allow anyone to remove user documents
  remove: () => true,
});

// Insert a new user document asynchronously
export async function createUser(user: User): Promise<string> {
  // Insert user into the collection and return its ID
  return await UserCollection.insertAsync(user);
}

// Retrieve a user by their email address
export async function getUserByEmail(email: string): Promise<User | undefined> {
  // Find and return a user document matching the provided email
  return await UserCollection.findOneAsync({ email });
}

// Retrieve a user by their unique ID
export async function getUserById(_id: any): Promise<User | undefined> {
  // Find and return a user document matching the provided ID
  return await UserCollection.findOneAsync({ _id });
}

// Update a user's gesture settings
export async function updateUserSettings(_id: string, settings: Record<GestureType, FunctionType>): Promise<number> {
  // Replace the user's current settings with the provided mapping
  return await UserCollection.updateAsync(_id, { $set: { settings } });
}

// Retrieve a user's gesture-function settings, filling in defaults for missing gestures
export async function getUserSettings(email: string): Promise<Record<GestureType, FunctionType>> {
  // Query user settings only (exclude _id)
  const user = await UserCollection.findOneAsync({ email }, { projection: { settings: 1, _id: 0 } });

  // If the user exists and has settings defined
  if (user) {
    // Create a result mapping to hold all gesture-function pairs
    const result = {} as Record<GestureType, FunctionType>;

    // Convert stored settings to proper enum-based keys and values
    Object.entries(user.settings).forEach(([key, value]) => {
      const gestureKey = Number(key) as GestureType;
      const functionValue = value as FunctionType;
      result[gestureKey] = functionValue;
    });

    // Fill in any missing gesture mappings with UNUSED
    Object.values(GestureType)
      .filter((v) => typeof v === "number")
      .forEach((g: number) => {
        if (result[g as GestureType] === undefined) {
          result[g as GestureType] = FunctionType.UNUSED;
        }
      });

    // Return the complete gesture mapping
    return result;
  } else {
    // Return default mapping if user does not exist
    return defaultMapping;
  }
}

// Update user details using their email address
export async function updateUser(email: string, updates: Partial<User>): Promise<number> {
  // Apply partial updates to the user's document
  return await UserCollection.updateAsync({ email }, { $set: updates });
}

// Delete a user by their email address
export async function deleteUser(email: string): Promise<number> {
  // Remove the user document from the collection
  return await UserCollection.removeAsync({ email });
}

// Check if a user exists by email
export async function doesUserExist(email: string): Promise<boolean> {
  // Look up a user by email and return true if found
  const user = await UserCollection.findOneAsync({ email });
  return !!user;
}

// Verify user login credentials
export async function correctLogin(email: string, password: string): Promise<boolean> {
  // Retrieve the user by email
  const user = await getUserByEmail(email);

  // If user does not exist, return false
  if (!user) return false;

  // Verify the password against the stored hash
  return verifyPassword(password, user.password);
}

// Retrieve the ID of the user's most recently used presentation
export async function getRecentPresentationId(userId: string): Promise<string | undefined> {
  // Query for the recent presentation field only
  const user = await UserCollection.findOneAsync({ _id: userId }, { projection: { _recent_presentation_id: 1, _id: 0 } });

  // Return the recent presentation ID if it exists
  return user?._recent_presentation_id;
}

// Update the user's most recent presentation ID
export async function updateRecentPresentationId(userId: string, presentationId: string): Promise<number> {
  // Set the _recent_presentation_id field to the provided presentation ID
  return await UserCollection.updateAsync({ _id: userId }, { $set: { _recent_presentation_id: presentationId } });
}
